"""
90
КиберКодер — известный в узких кругах хакер. Уже много лет его занимает одна задача. Он хочет взломать шифр,
за которым прячется ответ на главный вопрос Вселенной. КиберКодеру очень бы пригодилась ваша помощь.

Для первого этапа взлома КиберКодеру нужно подобрать номера портов сервера, к которым он сможет подключиться.
Известно, что это четные числа, которые находятся в определенном диапазоне.

Напишите функцию even_numbers(), которая найдет все четные числа в диапазоне. Она принимает два аргумента — начало
и конец промежутка, внутри которого нужно будет найти четные цифры. Сохраните в список все четные числа в заданном
диапазоне и верните этот список в качестве ответа.
"""

def even_numbers(start, end):
    arr = []
    for i in range(start, end + 1):
        arr.append(i) if i % 2 == 0 else None
    return arr

#print(even_numbers(5, 10))

"""
91
Отлично, КиберКодеру удалось подключиться к серверу! Следующий шаг — найти номера директорий с файлами, 
которые отвечают за шифрование.

Известно, что важные файлы хранятся в директориях с нечетными номерами. Но следует быть осторожным — директория 
с номером 359 защищена особым файерволом. Если ее открыть, хакера тут же обнаружат.

Создайте функцию directories_check(), которая принимает один аргумент — список целых чисел. Каждое число в 
этом списке — это номер директории. Функция должна сохранить все нечетные номера в отдельный список и вернуть 
его в качестве ответа. Если в исходном списке встретилась директория с номером 359, остановите проверку и сохраните 
только те нечетные числа, которые попали в список до 359. Число 359 не должно попасть в ответ.
"""

def directories_check(num):
    owen = []
    for i in num:
        if i == 359:
            return owen
        if i % 2 != 0:
            owen.append(i)
    return owen

#print(directories_check([2, 5, 6, 45674, 32, 359, 563, 358]))

"""
92
Благодаря функции directories_check(), которую вы создали в предыдущем задании, КиберКодер собрал несколько списков 
директорий. Помогите ему определить самые важные из них, которые следует проверить. Самыми важными считаются директории, 
которые встречаются сразу в нескольких списках.

Создайте функцию crosscheck(), которая принимает на вход два аргумента — два списка целых чисел. Функция должна 
найти числа, которые есть сразу в двух списках. В качестве ответа верните список этих чисел. Используйте циклы 
для решения задачи.
"""

def crosscheck(num1, num2):
    return list(set(num1) & set(num2))

#print(crosscheck([3,2,5,3,5,3,5,6,7,2], [1,8,6,9,0,4,5]))

"""
93
Отлично, благодаря вашей помощи КиберКодер смог выбрать самые важные директории. Он получил доступ к засекреченным 
файлам, которые зашифрованы. Чтобы их расшифровать, КиберКодеру нужно рассчитать уникальные ключи. 
Уникальный ключ — это сумма всех цифр из номера директории.

Создайте функцию unique_key(), которая принимает один аргумент — целое положительное число. Функция unique_key 
должна найти сумму всех цифр числа из аргумента. Верните эту сумму в качестве ответа. Используйте цикл while 
для решения задачи.
"""

def unique_key(num):
    tmp = list(tuple(str(num)))
    print(tmp)
    x = 0
    while len(tmp) > 0:
        x += int(tmp.pop())
    return x

#print(unique_key(111))

"""
94
КиберКодеру удалось расшифровать засекреченные файлы с вашей помощью! Внутри каждого файла оказалась длинная строка. 
Чтобы определить ее смысл, КиберКодер решил провести частотный анализ.

Частотный анализ — это метод расшифровки сообщений, который основан на поиске частоты повторения символов. 
С его помощью можно сопоставить частоту повторения букв в сообщении и в алфавите. Расшифровать текст можно, если 
заменить буквы зашифрованного сообщения на соответствующие буквы стандартного алфавита.

Создайте функцию count_letters(), которая посчитает, сколько раз буква повторяется в строке. Функция должна принимать 
два аргумента — строку, которую нужно проанализировать, и букву, частоту повторения которой нужно найти. В качестве 
ответа верните одно число — количество повторений буквы в строке.
"""

def count_letters(text, letter):
    return text.count(letter)

#print(count_letters("wnweweonqwdoqwdoqwdonec", "w"))

"""
95
Частотный анализ помог КиберКодеру сопоставить буквы русского алфавита с буквами в зашифрованном сообщении. 
Хакер заменил все буквы в зашифрованном файле на цифры, которые соответствуют номерам букв в алфавите. Букве А он 
присвоил номер 0, букве Б — номер 1 и так далее. Помогите КиберКодеру расшифровать сообщение.

Напишите функцию decipher(), которая заменит все числа в строке на буквы русского алфавита. Функция должна принимать 
один аргумент — строку с целыми числами от 0 до 32, между которыми стоит пробел. В качестве ответа верните строку 
с последовательностью букв без пробелов и других разделителей. Используйте только строчные буквы.
"""

def decipher(text):
    tmp = text.split()
    abc = ["а", "б", "в", "г", "д", "е", "ё", "ж", "з", "и", "й", "к", "л", "м", "н", "о", "п", "р", "с", "т", "у", "ф", "х", "ц", "ч", "ш", "щ", "ъ", "ы", "ь", "э", "ю", "я"]
    result = ''
    for i in tmp:
        result += abc[int(i)]

    return result

# print(decipher("1 4 2 7 8 22 6 17"))

"""
96
В конце концов КиберКодер узнал самую главную тайну. Она оказалась настолько страшной, что ее нельзя доверить ни 
одному человеку в мире. КиберКодеру придется вновь ее зашифровать.
Самые сложные шифры основаны на факторизации, то есть разложении чисел на множители. 
КиберКодер вновь просит вас о помощи.

Создайте функцию all_dividers(), которая найдет все делители числа. Она должна принимать на вход один аргумент — число, 
которое нужно разложить на множители. В качестве ответа верните список со всеми делителями исходного числа.
"""

def all_dividers(num):
    divider = []
    for i in range(1, num + 1):
        if num % i == 0:
            divider.append(i)
    return divider

print(all_dividers(12))
