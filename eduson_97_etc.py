"""
97
Дан одномерный массив числовых значений array с N элементами. Напишите функцию swap_groups, которая поменяет местами
группу из M элементов, которые начинаются с индекса K, с группой из M элементов, которые начинаются с индекса P.
Функция swap_groups должна вернуть измененный массив.
Например, на вход программы передали массив
array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
переменные N = 10, M = 3, K = 1 и P = 6.
Функция swap_groups в таком случае должна поменять местами три элемента с индексами 1, 2 и 3 с тремя элементами
с индексами 6, 7 и 8. В результате должен получиться массив [1, 7, 8, 9, 5, 6, 2, 3, 4, 10].
Используйте срезы массива, чтобы выделить группы элементов с индекса K и индекса P.
"""
def swap_groups(array, N, M, K, P):
    if K + M > N or P + M > N:
        return "Некорректные значения K, P или M"
    tmpK = array[K:K+M]
    tmpP = array[P:P + M]
    array[K:K+M] = tmpP
    array[P:P+M] = tmpK
    return array

array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
N = 10
M = 3
K = 1
P = 6
#print(array)
#print(swap_groups(array, N, M, K, P))

"""
98
Дан одномерный массив чисел array, в котором N элементов. Напишите функцию process_array, которая подсчитает, 
сколько чисел в массиве делятся на 3 нацело, и вычислит среднее арифметическое четных чисел. 
Функция process_array должна добавить эти значения в новые элементы на первом и последнем местах в массиве соответственно. 
Верните измененный массив в качестве ответа.
Например, на вход программы передали массив array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]. 
В нем три элемента делятся нацело на 3, а среднее арифметическое четных чисел — 6. 
В результате должен получиться массив [3, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 6.0].
"""
def process_array(array):
    chet = 0
    chet_count = 0
    tri = 0
    for el in array:
        if el % 3 == 0:
            tri += 1
        if el % 2 == 0:
            chet_count += 1
            chet += el
    array.insert(0, tri)
    array.append(int(chet/chet_count))
    return array

array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
#print(process_array(array))

"""
99
В игре «Битва карт» карточная колода раздается поровну двум игрокам, карты выдаются в случайном порядке. 
Игроки вскрывают по одной верхней карте, и тот, чья карта старше, забирает обе вскрытые карты и помещает их вниз своей колоды. 
Игрок, который остался без карт, проигрывает.
Все карты в колоде различны по номиналу, старшая карта побеждает младшую. Игрок, который забирает карты, кладет сначала 
карту первого игрока, затем свою карту вниз своей колоды.
Напишите программу, которая моделирует игру «Битва карт» и определяет победителя. В игре участвуют 10 карт со 
значениями от 0 до 9. Большая карта побеждает меньшую, карта со значением 0 побеждает карту 9 (и только ее).
Программа получает на вход две строки: первая строка содержит 5 чисел, которые разделены пробелами, — номера карт 
первого игрока, вторая строка — 5 карт второго игрока. Карты перечислены сверху вниз, то есть каждая строка 
начинается с карты, которая будет открыта первой.
Программа должна определить победителя при данной раздаче и вывести слово "first" или "second", а также количество 
ходов до выигрыша. Если игра не заканчивается за 100 ходов, между игроками ничья, программа должна вывести слово "tie". 
Для решения задачи используйте очередь.
Например, на вход программы передали две строки чисел: 1 3 5 7 9 и 2 4 6 8 0. В таком случае второй игрок победит 
первого за 5 ходов. Программа должна вернуть ответ second 5.
"""

def card_game(player1, player2):
    arr1 = player1.split(' ')
    arr2 = player2.split(' ')
    turn = 0
    while len(arr1) > 0 and len(arr2) > 0:
        card1 = int(arr1.pop(0))
        card2 = int(arr2.pop(0))
        if card1 == 0 and card2 == 9:
            arr1.append(card2)
            arr1.append(card1)
            turn += 1
            continue
        elif card1 == 9 and card2 == 0:
            arr2.append(card1)
            arr2.append(card2)
            turn += 1
            continue
        if card1 > card2:
            arr1.append(card1)
            arr1.append(card2)
            turn += 1
            continue
        elif card2 > card1:
            arr2.append(card2)
            arr2.append(card1)
            turn += 1
            continue
        if turn == 100:
            return "tie"

    if len(arr1) > 0 and len(arr2) == 0:
        return f"first {turn}"
    elif len(arr1) == 0 and len(arr2) > 0:
        return f"second {turn}"

player1 = '1 3 5 7 9'
player2 = '2 4 6 8 0'
#print(card_game(player1, player2))

"""
100
Дана строка, которая состоит из круглых скобок. Создайте функцию row_check, которая определит, какое наименьшее 
количество символов необходимо удалить из этой строки, чтобы получилась правильная скобочная последовательность.
Правильная скобочная последовательность — это строка, в которой каждая открывающая скобка имеет соответствующую 
закрывающую скобку и скобки правильно вложены. Например, правильные скобочные последовательности могут выглядеть так: 
(), (()), (()(())). Неправильные скобочные последовательности выглядят так: (, ), ((), ())(.
На вход программы передается строка из круглых скобок. Длина строки не превосходит 100 символов. 
Функция row_check должна вернуть одно число — минимальное количество символов, которые необходимо удалить. 
Используйте стек для решения задачи.
"""
def row_check(s):
    stack = []
    remove_count = 0

    for i in range(len(s)):
        if s[i] == '(':
            # Добавляем индекс открытой скобки в стек
            stack.append(i)
        elif s[i] == ')':
            if len(stack) > 0:
                # Удаляем последнюю открытую скобку из стека,
                # если ей соответствует закрывающая скобка
                stack.pop()
            else:
                # Закрывающая скобка без пары - считаем удаление
                remove_count += 1

    # Складываем количество лишних закрытых скобок
    # и оставшихся открытых скобок в стеке
    return remove_count + len(stack)

#print(row_check('(()(()))'))

"""
101
Напишите функцию graph_check, которая проверяет, является ли заданный неориентированный граф связным.
Связный граф — это такой граф, в котором существует путь между любыми двумя его вершинами. То есть из одной его вершины 
можно добраться до любой другой. Граф задается списком ребер.
На вход программы три аргумента. Два числа — количество вершин графа V и количество ребер E. Третий аргумент — список 
длиной E, где каждый элемент — это кортеж из двух чисел u и v. Число u — это номер вершины, из которой ребро выходит. 
Число v — номер вершины, в которую ребро приходит. Программа должна вернуть ответ YES, если граф является связным, 
и NO в любом ином случае. Используйте DFS для решения задачи.
Сохраните ребра графа в многомерный список. Каждый элемент такого списка — это две вершины, которые составляют ребро.
"""

def graph_check(V, E, edges):
    # Создайте список смежности для графа
    adj_list = [[] for _ in range(E+1)]
    for u, v in edges:
        adj_list[u-1].append(v-1)
        adj_list[v-1].append(u-1)

    # Создайте функцию для выполнения DFS
    # Оформлять поиск в отдельной функции не обязательно,
    # но это поможет уменьшить размер программы
    def dfs(node, visited):
        stack = [node]
        while stack:
            current = stack.pop()
            if not visited[current]:
                visited[current] = True
                for neighbor in adj_list[current]:
                    if not visited[neighbor]:
                        stack.append(neighbor)

    # Проверьте связность графа
    visited = [False] * V
    dfs(0, visited)

    # Если все вершины посетили, граф связный
    if all(visited):
        return "YES"
    else:
        return "NO"


"""
101
Дано бинарное дерево поиска, в котором каждый узел содержит ключ (уникальное целое число) и ссылки на левого и правого 
потомка. Напишите функцию find_max_key, которая находит узел с максимальным ключом в этом дереве.
Функция find_max_key принимает на вход корень root бинарного дерева. В результате функция должна вернуть значение 
максимального ключа в дереве. Если дерево пустое, верните 0. 
Для обхода бинарного дерева поиска используйте рекурсивную функцию.
"""


class TreeNode:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None


def find_max_key(root):
    # Базовый случай: если дерево пустое, возвращаем 0
    if root is None:
        return 0

    # Рекурсивно идём вправо, пока не найдём крайний правый лист
    while root.right is not None:
        root = root.right

    # Возвращаем максимальное найденное значение
    return root.key

"""
103
Создайте функцию longest_increasing_subsequence, которая находит длину наибольшей возрастающей подпоследовательности в массиве чисел.
Возрастающая подпоследовательность — это последовательность чисел, где каждое следующее число больше предыдущего, не 
обязательно подряд. Например, в массиве [10, 9, 2, 5, 3, 7, 101, 18] наибольшими возрастающими подпоследовательностями 
будут [2, 3, 7, 101] или [2, 5, 7, 18], их длина равна 4.
Функция longest_increasing_subsequence принимает на вход список целых чисел. В качестве ответа функция должна вернуть 
длину наибольшей возрастающей подпоследовательности. Используйте динамическое программирование для решения задачи.
"""